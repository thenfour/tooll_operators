{
  "Name": "ASCIIFilterRef2XXX",
  "_id": "5b8c2425-5085-48dc-8c4e-36ebee2030f5",
  "Namespace": "user.tenfour",
  "Description": "13 Dec 2019\r\n- remove dither\r\n- better image sampling\r\n\r\n\r\nif Scale < 0, then we look for scale in the RefFont input.",
  "Inputs": [
    {
      "Name": "Code",
      "MetaInstanceID": "5d24d5e3-f163-48ad-87e5-1526fa4504ec",
      "DefaultValue": {
        "Type": "Text",
        "Value": [
          "\r",
          "\r",
          "//>>> __defines\r",
          "#define DIMENSIONS 6\r",
          "#define VALUEELEMENTS 8\r",
          "#define PIXELFORMAT_SQUARE\r",
          "#define COLORSPACE_LAB\r",
          "\r",
          "//<<< __defines\r",
          "\r",
          "\r",
          "//>>> _common parameters\r",
          "float4x4 objectToWorldMatrix;",
          "float4x4 worldToCameraMatrix;",
          "float4x4 projMatrix;",
          "Texture2D txDiffuse;",
          "float2 RenderTargetSize;",
          "//<<< _common parameters\r",
          "\r",
          "//>>> _parameters\r",
          "Texture2D Image;",
          "float Scale;",
          "float FiveTileSampleAmt;",
          "//<<< _parameters\r",
          "Texture2D RefImage;\r",
          "Texture2D FontImage;\r",
          "const float2 CharSize;\r",
          "const int PixelFormat;// 0 = square, 1=five tile\r",
          "const int ColorSpace;// 0=hsl, 1=jpeg, 2=lab, 3=nyuv\r",
          "const float ValuesPerTile;\r",
          "const float2 LuminanceTiles;\r",
          "const float ChromaElements;\r",
          "const float MapEntryCount;\r",
          "\r",
          "SamplerState samLinear\r",
          "{\r",
          "    Filter = MIN_MAG_MIP_LINEAR;\r",
          "    AddressU = Wrap;\r",
          "    AddressV = Wrap;\r",
          "};\r",
          "\r",
          "struct VS_IN\r",
          "{\r",
          "    float4 pos : POSITION;\r",
          "    float2 texCoord : TEXCOORD;\r",
          "};\r",
          "\r",
          "struct PS_IN\r",
          "{\r",
          "    float4 pos : SV_POSITION;\r",
          "    float2 texCoord: TEXCOORD0;\r",
          "};\r",
          "\r",
          "//>>> _GS\r",
          "",
          "//<<< _GS\r",
          "\r",
          "//>>> _VS \r",
          "PS_IN VS( VS_IN input )",
          "{",
          "    PS_IN output = (PS_IN)0;",
          "",
          "    output.pos = mul(input.pos, worldToCameraMatrix);",
          "    output.pos = mul(output.pos, projMatrix);",
          "    output.texCoord = input.texCoord;",
          "",
          "    return output;",
          "}",
          "//<<< _VS\r",
          "\r",
          "//>>> PS\r",
          "#if !defined(DIMENSIONS)\r",
          "#define DIMENSIONS 20 // practical maximum. shouldn't ever happen though.\r",
          "#endif\r",
          "#if !defined(VALUEELEMENTS)\r",
          "#define VALUEELEMENTS 20\r",
          "#endif\r",
          "\r",
          "#define Epsilon (1e-10)\r",
          "\r",
          "// PIXELFORMAT_SQUARE\r",
          "// PIXELFORMAT_FIVETILE\r",
          "// PIXELFORMAT_UNKNOWN\r",
          "\r",
          "// COLORSPACE_HSL\r",
          "// COLORSPACE_JPEG\r",
          "// COLORSPACE_LAB\r",
          "// COLORSPACE_NYUV\r",
          "// COLORSPACE_UNKNOWN\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "// RGB -> HSL conversion\r",
          "\r",
          "float3 RGBtoHCV(in float3 RGB)\r",
          "{\r",
          "    // Based on work by Sam Hocevar and Emil Persson\r",
          "    float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0/3.0) : float4(RGB.gb, 0.0, -1.0/3.0);\r",
          "    float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);\r",
          "    float C = Q.x - min(Q.w, Q.y);\r",
          "    float H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);\r",
          "    return float3(H, C, Q.x);\r",
          "}\r",
          "float3 RGBtoHSL(in float3 RGB)\r",
          "{\r",
          "    float3 HCV = RGBtoHCV(RGB);\r",
          "    float L = HCV.z - HCV.y * 0.5;\r",
          "    float S = HCV.y / (1 - abs(L * 2 - 1) + Epsilon);\r",
          "    return float3(HCV.x, S, L);\r",
          "}\r",
          "\r",
          "float3 rgb2NormalizedHSL(float3 c) {\r",
          "    return RGBtoHSL(c).zxy; // expects luma to be 1st component\r",
          "}\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "// RGB -> JPEG conversion\r",
          "float3 rgb2JPEG(float3 c) {\r",
          "    float Y = (0.2989 * c.r + 0.5866 * c.g + 0.1145 * c.b);\r",
          "    float Cb = (-0.1687 * c.r - 0.3313 * c.g + 0.5000 * c.b);\r",
          "    float Cr = (0.5000 * c.r - 0.4184 * c.g - 0.0816 * c.b);\r",
          "    float3 ret;\r",
          "    ret.x = Y;\r",
          "    ret.y = Cb; // -.5, .5 center 0\r",
          "    if (ret.y < 0)\r",
          "        ret.y += 1;\r",
          "    ret.z = Cr; // -.5, .5 center 0\r",
          "    if (ret.z < 0)\r",
          "        ret.z += 1;\r",
          "    return ret;\r",
          "}\r",
          "\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "// RGB -> LAB conversion\r",
          "// https://github.com/sv3/gift/blob/master/RGB2Lab.glsl\r",
          "float3 RGB2Lab(float3 rgb){\r",
          "    float R = rgb.x;\r",
          "    float G = rgb.y;\r",
          "    float B = rgb.z;\r",
          "    // threshold\r",
          "    float T = 0.008856;\r",
          "\r",
          "    float X = R * 0.412453 + G * 0.357580 + B * 0.180423;\r",
          "    float Y = R * 0.212671 + G * 0.715160 + B * 0.072169;\r",
          "    float Z = R * 0.019334 + G * 0.119193 + B * 0.950227;\r",
          "\r",
          "    // Normalize for D65 white point\r",
          "    X = X / 0.950456;\r",
          "    Y = Y;\r",
          "    Z = Z / 1.088754;\r",
          "\r",
          "    bool XT, YT, ZT;\r",
          "    XT = false; YT=false; ZT=false;\r",
          "    if(X > T) XT = true;\r",
          "    if(Y > T) YT = true;\r",
          "    if(Z > T) ZT = true;\r",
          "\r",
          "    float Y3 = pow(abs(Y),1.0/3.0);\r",
          "    float fX, fY, fZ;\r",
          "    if(XT){ fX = pow(abs(X), 1.0/3.0);} else{ fX = 7.787 * X + 16.0/116.0; }\r",
          "    if(YT){ fY = Y3; } else{ fY = 7.787 * Y + 16.0/116.0 ; }\r",
          "    if(ZT){ fZ = pow(abs(Z),1.0/3.0); } else{ fZ = 7.787 * Z + 16.0/116.0; }\r",
          "\r",
          "    float L; if(YT){ L = (116.0 * Y3) - 16.0; }else { L = 903.3 * Y; }\r",
          "    float a = 500.0 * ( fX - fY );\r",
          "    float b = 200.0 * ( fY - fZ );\r",
          "\r",
          "    return float3(L,a,b);\r",
          "}\r",
          "\r",
          "float3 rgb2NormalizedLAB( float3 c ) {\r",
          "    float3 lab = RGB2Lab(c);\r",
          "    float3 ret;\r",
          "    ret.x = lab.x / 100.0;\r",
          "    ret.y = lab.y / 255.0;\r",
          "    ret.z = lab.z / 255.0;\r",
          "    if (ret.y < 0)\r",
          "        ret.y += 1;\r",
          "    if (ret.z < 0)\r",
          "        ret.z += 1;\r",
          "    return ret;\r",
          "}\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "// RGB -> NYUV conversion\r",
          "float3 rgbToNYUV(float3 c) {\r",
          "    float3 ret;\r",
          "    ret.x = (c.r + c.g + c.b) / 3;// 0-1\r",
          "    ret.y = (c.g - c.b) / 2;\r",
          "    if (ret.y < 0)\r",
          "        ret.y += 1;\r",
          "    ret.z = (c.r - c.b) / 2;\r",
          "    if (ret.z < 0)\r",
          "        ret.z += 1;\r",
          "    return ret;\r",
          "}\r",
          "\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "float GetLuma(float3 c){\r",
          "#if defined(COLORSPACE_NYUV)\r",
          "    return (c.r + c.g + c.b)/3.0;\r",
          "#endif\r",
          "    return 0.2989 * c.r + 0.5866 * c.g + 0.1145 * c.b;\r",
          "}\r",
          "\r",
          "float3 GetNativeColor(float3 inp) {\r",
          "#if defined(COLORSPACE_HSL)\r",
          "    return clamp(rgb2NormalizedHSL(inp),0,1);\r",
          "#elif defined(COLORSPACE_LAB)\r",
          "    return clamp(rgb2NormalizedLAB(inp),0,1);\r",
          "#elif defined(COLORSPACE_NYUV)\r",
          "    return clamp(rgbToNYUV(inp),0,1);\r",
          "#elif defined(COLORSPACE_JPEG)\r",
          "    return clamp(rgb2JPEG(inp),0,1);\r",
          "#endif\r",
          "    return inp;\r",
          "}\r",
          "\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "float4 PS_Square( float2 pos)\r",
          "{\r",
          "    // the upper-left pixel position of the character-sized cell.\r",
          "    // todo: set these as external params\r",
          "    float2 ScaledCharSize = CharSize * Scale;\r",
          "    float refW, refH;\r",
          "    RefImage.GetDimensions(refW, refH);\r",
          "    float fontImgW, fontImgH;\r",
          "    FontImage.GetDimensions(fontImgW, fontImgH);\r",
          "    uint fontCellsX = (uint)(fontImgW / CharSize.x);\r",
          "    float halfSegCenter = 0.25 / ValuesPerTile;\r",
          "    float lumaComponents = LuminanceTiles.x * LuminanceTiles.y;\r",
          "\r",
          "    uint2 srcCell = floor(pos / ScaledCharSize);\r",
          "    int2 srcCellOrigin = srcCell * ScaledCharSize;// pixel position of the cell upper left\r",
          "    int2 srcCellPos = pos - srcCellOrigin; // pixel position within this cell, 0-ScaledCharSize\r",
          "    float2 HalfTileSize = ScaledCharSize / 2.;\r",
          "    srcCellPos /= Scale;// now in coords that play well with the font texture\r",
          "    \r",
          "    float vals[VALUEELEMENTS];\r",
          "    float3 charRGB = float3(0,0,0);// accumulator\r",
          "    for (int ty = 0; ty < LuminanceTiles.y; ++ ty) {\r",
          "        for (int tx = 0; tx < LuminanceTiles.x; ++ tx) {\r",
          "            float2 tileIndex = float2(tx, ty);\r",
          "            float2 tilePos = (tileIndex / LuminanceTiles) * ScaledCharSize; // pixel position of the upper-left corner of this tile relative to the char cell\r",
          "            float3 srcColor = Image.Load(int3(srcCellOrigin + tilePos + HalfTileSize + .5, 0)).rgb; // sample the center-ish pix of this tile\r",
          "        \r",
          "            vals[tx + ty * LuminanceTiles.x] = clamp(GetLuma(srcColor), 0, 1);// verified with off-axis lines\r",
          "            charRGB += srcColor;\r",
          "        }\r",
          "    }\r",
          "    \r",
          "    if (ChromaElements >= 2.0) {\r",
          "        charRGB /= lumaComponents;\r",
          "        float3 charYUV = GetNativeColor(charRGB);\r",
          "        vals[lumaComponents] = charYUV.g;\r",
          "        vals[lumaComponents + 1] = charYUV.b;\r",
          "    }\r",
          "    \r",
          "    uint ID = 0;\r",
          "    for (int i = lumaComponents + ChromaElements - 1; i >= 0 ; -- i) {\r",
          "        float v = vals[i];\r",
          "        v -= halfSegCenter;\r",
          "        v = clamp(v, 0, 1);\r",
          "        v *= ValuesPerTile;\r",
          "        ID *= ValuesPerTile;\r",
          "        ID += (int)floor(v);\r",
          "    }\r",
          "    \r",
          "    int2 refCell = int2(ID % (uint)refW, ID / (uint)refW);\r",
          "    \r",
          "    float3 ref = RefImage.Load(int3(refCell, 0)).rgb * 255.0;\r",
          "    \r",
          "    // convert ref to linear index.\r",
          "    int fontID = ((int)ref.r) + ((int)ref.g * 256) + ((int)ref.b * 65536);\r",
          "    int2 fontCell = int2(fontID % fontCellsX, fontID / fontCellsX);\r",
          "\r",
          "    float3 fontColor = FontImage.Load(int3((fontCell * CharSize) + srcCellPos, 0)).rgb;\r",
          "    return float4(fontColor,1);\r",
          "}\r",
          "\r",
          "\r",
          "float3 ImageSample(float2 texCoord/*, float2 pixelOffset*/)\r",
          "{\r",
          "    //float w, h;\r",
          "    //Image.GetDimensions(w, h);\r",
          "    //pixelOffset /= float2(w, h);\r",
          "    //return Image.Sample(samLinear, texCoord + pixelOffset).rgb;\r",
          "    return Image.Sample(samLinear, texCoord).rgb;\r",
          "}\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "// returns luma\r",
          "\r",
          "// pt = 0-1 point within the char tile to sample.\r",
          "// \r",
          "float FiveTileSample(float2 pt, inout float4 charRGB, float2 ScaledCharSize, float2 srcCellOrigin, float2 texCoordCellOrigin) {\r",
          "    //uint2 px = srcCellOrigin + (ScaledCharSize * pt);\r",
          "    //float2 px = ;\r",
          "    //float3 srcColor = Image.Load(uint3(px, 0)).rgb;\r",
          "    //float3 srcColor = ImageSample(texCoordCellOrigin, (ScaledCharSize * pt));\r",
          "    float3 srcColor = ImageSample(texCoordCellOrigin + ScaledCharSize * pt);//, (ScaledCharSize * pt));\r",
          "    \r",
          "    charRGB.rgb += srcColor;\r",
          "    charRGB.w ++;\r",
          "    return clamp(GetLuma(srcColor), 0, 1);\r",
          "}\r",
          "\r",
          "float4 PS_FiveTile( float2 pos, float2 texCoord)\r",
          "{\r",
          "    //return float4(ImageSample(texCoord, float2(0,0)), 1);\r",
          "\r",
          "    float2 ScaledCharSizePx = CharSize * Scale; // size in pixels of the resulting char cell (8 * 2 = 16)\r",
          "    float refW, refH;\r",
          "    RefImage.GetDimensions(refW, refH);\r",
          "    float fontImgW, fontImgH;\r",
          "    FontImage.GetDimensions(fontImgW, fontImgH);\r",
          "    uint fontCellsX = (uint)(fontImgW / CharSize.x);\r",
          "    float halfSegCenter = 0.25 / ValuesPerTile;\r",
          "    float lumaComponents = 5;\r",
          "\r",
          "    int2 srcCellOriginPx = floor(pos / ScaledCharSizePx) * ScaledCharSizePx;// pixel position of the cell upper left\r",
          "\r",
          "    float imgW, imgH;\r",
          "    Image.GetDimensions(imgW, imgH);\r",
          "\r",
          "    float2 CharSizeImgTexCoords = ScaledCharSizePx / RenderTargetSize.xy;// size in source image texcoords of a char cell\r",
          "    float2 texCoordCellOrigin = floor(texCoord / CharSizeImgTexCoords) * CharSizeImgTexCoords;\r",
          "    \r",
          "    int2 srcCellPos = pos - srcCellOriginPx; // pixel position within this cell, 0-ScaledCharSize\r",
          "    //float2 HalfTileSizePx = ScaledCharSizePx / 2.;\r",
          "    srcCellPos /= Scale;// now in coords that play well with the font texture\r",
          "    \r",
          "    float vals[VALUEELEMENTS];\r",
          "    float4 charRGB = float4(0,0,0,0);// accumulator. w = count of accumulations\r",
          "    \r",
          "    if (FiveTileSampleAmt < 6.) {\r",
          "        // 5 samples. deviation from the C# code is that the Y is inverted. so bottom = top and vice versa.\r",
          "        // upper left\r",
          "        vals[2] = FiveTileSample(float2(.3, .9), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin);\r",
          "        // upper right\r",
          "        vals[3] = FiveTileSample(float2(.9, .7), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin);\r",
          "        // bottom left\r",
          "        vals[0] = FiveTileSample(float2(.1, .3), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin);\r",
          "        // bottom right\r",
          "        vals[1] = FiveTileSample(float2(.7, .1), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin);\r",
          "        // center\r",
          "        vals[4] = FiveTileSample(float2(.5, .5), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin);\r",
          "    } else {\r",
          "        // upper left\r",
          "        vals[2] = (FiveTileSample(float2(.1, .9), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)\r",
          "            + FiveTileSample(float2(.5, .9), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)) / 2.;\r",
          "        // upper right\r",
          "        vals[3] = (FiveTileSample(float2(.9, .9), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)\r",
          "            + FiveTileSample(float2(.9, .5), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)) / 2.;\r",
          "        // bottom left\r",
          "        vals[0] = (FiveTileSample(float2(.1, .5), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)\r",
          "            + FiveTileSample(float2(.1, .1), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)) / 2.;\r",
          "        // bottom right\r",
          "        vals[1] = (FiveTileSample(float2(.9, .1), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)\r",
          "            + FiveTileSample(float2(.5, .1), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin)) / 2.;\r",
          "        // center\r",
          "        vals[4] = FiveTileSample(float2(.5, .5), charRGB, CharSizeImgTexCoords, float2(0,0), texCoordCellOrigin);\r",
          "    }\r",
          "    \r",
          "    if (ChromaElements >= 2.0) {\r",
          "        charRGB.rgb /= charRGB.w;\r",
          "        float3 charYUV = GetNativeColor(charRGB.rgb);\r",
          "        vals[lumaComponents] = charYUV.g;\r",
          "        vals[lumaComponents + 1] = charYUV.b;\r",
          "    }\r",
          "    \r",
          "    uint ID = 0;\r",
          "    for (int i = lumaComponents + ChromaElements - 1; i >= 0 ; -- i) {\r",
          "        float v = vals[i];\r",
          "        v -= halfSegCenter;\r",
          "        v = clamp(v, 0, 1);\r",
          "        v *= ValuesPerTile;\r",
          "        ID *= ValuesPerTile;\r",
          "        ID += (int)floor(v);\r",
          "    }\r",
          "    \r",
          "    int2 refCell = int2(ID % (uint)refW, ID / (uint)refW);\r",
          "    \r",
          "    float3 ref = RefImage.Load(int3(refCell, 0)).rgb * 255.0;\r",
          "    \r",
          "    // convert ref to linear index.\r",
          "    int fontID = ((int)ref.r) + ((int)ref.g * 256) + ((int)ref.b * 65536);\r",
          "    int2 fontCell = int2(fontID % fontCellsX, fontID / fontCellsX);\r",
          "\r",
          "    float3 fontColor = FontImage.Load(int3((fontCell * CharSize) + srcCellPos, 0)).rgb;\r",
          "    return float4(fontColor,1);\r",
          "}\r",
          "\r",
          "\r",
          "\r",
          "\r",
          "///////////////////////////////////////////////////////////////////////////\r",
          "float4 PS( PS_IN input ) : SV_Target\r",
          "{\r",
          "#if defined(PIXELFORMAT_SQUARE)\r",
          "        return PS_Square(input.pos.xy);\r",
          "#elif defined(PIXELFORMAT_FIVETILE)\r",
          "        return PS_FiveTile(input.pos.xy, input.texCoord.xy);\r",
          "#else\r",
          "        return float4(0, 0, 1, 1);\r",
          "#endif\r",
          "}\r\r\r\r",
          "//<<< PS\r",
          "\r",
          "//>>> _technique\r",
          "technique10 Render",
          "{",
          "    pass P0",
          "    {",
          "        SetGeometryShader( 0 );",
          "        SetVertexShader( CompileShader( vs_4_0, VS() ) );",
          "        SetPixelShader( CompileShader( ps_4_0, PS() ) );",
          "    }",
          "}",
          "//<<< _technique\r",
          ""
        ]
      },
      "MetaID": "c522a66e-3260-4692-b3e3-79fd0361fa3d",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Image",
      "MetaInstanceID": "0541526f-a45f-4055-ad52-72b9e2682d53",
      "DefaultValue": {
        "Type": "Image",
        "Value": "Framefield.Core.Image"
      },
      "MetaID": "9848060d-fd84-45b0-b658-d0d531c61dab",
      "IsMultiInput": "False",
      "Relevance": "Required",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Map",
      "MetaInstanceID": "5e2d7ba7-1b22-4ea8-8f6f-102ceaadc304",
      "DefaultValue": {
        "Type": "Dynamic",
        "Value": "Framefield.Core.Dynamic"
      },
      "MetaID": "9701d534-b3ff-4889-a250-84aece4a7d76",
      "IsMultiInput": "False",
      "Relevance": "Required",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Scale",
      "MetaInstanceID": "322bfe5f-5ec2-4842-a262-b34b729cd4e4",
      "DefaultValue": {
        "Type": "Float",
        "Value": "-1"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "INTEGRAL.\r\nif <=0 , then scale is read from the font itself.\r\nif it's still <=0, then defaults to 1.\r\n",
      "Min": "-1",
      "Max": "10000",
      "Scale": "0.01",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "FiveTileSampleAmt",
      "MetaInstanceID": "d7478ed0-8900-4cc9-94aa-3b7e9925dee8",
      "DefaultValue": {
        "Type": "Float",
        "Value": "5"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "for the fivetile pixelformat, do we sample 5 pixels to map, or 9?\r\n",
      "Min": "5",
      "Max": "9",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": [
        {
          "Name": "Five",
          "Value": "5"
        },
        {
          "Name": "Nine",
          "Value": "9"
        }
      ]
    }
  ],
  "Outputs": [
    {
      "Name": "Image",
      "MetaInstanceID": "e0b5d238-3a1e-4324-95de-f92b14ffda58",
      "MetaID": "9848060d-fd84-45b0-b658-d0d531c61dab"
    }
  ],
  "OperatorParts": [
    {
      "MetaInstanceID": "c62d900e-5bdc-446c-b109-2a3f113c965f",
      "MetaID": "573196a0-4f12-49bd-a8ff-850fec74cf7b",
      "Name": "ASCIIFilterRef2XXXFunc",
      "Version": "c18a2346-9eb2-41c6-aeae-32588f99e81d",
      "Type": "Float",
      "IsMultiInput": "True",
      "Script": [
        "//>>> _using",
        "using System;",
        "using System.Collections.Generic;",
        "using System.Linq;",
        "using System.Text;",
        "using SharpDX;",
        "using SharpDX.Direct3D11;",
        "using SharpDX.Windows;",
        "//<<< _using",
        " ",
        "namespace Framefield.Core.ID573196a0_4f12_49bd_a8ff_850fec74cf7b",
        "{",
        "    public class Class_ASCIIFilterRef2 : FXImageFunction",
        "    {",
        "        //>>> _inputids",
        "        private enum InputId",
        "        {",
        "            Code = 0,",
        "            Image = 1,",
        "            Scale = 2,",
        "            Map = 3,",
        "            FiveTileSampleAmt = 4",
        "        }",
        "        //<<< _inputids",
        "",
        "        public override string GetCode(int idx) {",
        "            string code = base.GetCode(idx);",
        "            //return code;",
        "            if (string.IsNullOrEmpty(code)) {",
        "                Logger.Info(this,\"code empty\");",
        "                return code;",
        "            }",
        "            string openToken = \"//>>> __defines\";",
        "            string closeToken = \"//<<< __defines\";",
        "            var openSplit = code.Split(new string[] { openToken }, StringSplitOptions.None);",
        "            var closeSplit = code.Split(new string[] { closeToken }, StringSplitOptions.None);",
        "            if (openSplit.Length < 2) {",
        "                Logger.Info(this,\"code open defines not found.\");",
        "                return code;",
        "            }",
        "            if (closeSplit.Length < 2) {",
        "                Logger.Info(this,\"code close defines not found.\");",
        "                return code;",
        "            }",
        "            string beforeDefines = openSplit[0] + openToken + \"\\r\\n\";",
        "            string afterDefines = \"\\r\\n\" + closeToken + closeSplit[1];",
        "            ",
        "            string ret = beforeDefines + _defines + afterDefines;",
        "            //Logger.Info(this,\"Returning modified code, with #defines: {0}\", _defines);",
        "            return ret;",
        "        }",
        "",
        "        public override OperatorPartContext Eval(OperatorPartContext context, List<OperatorPart> inputs, int outputIdx) {",
        "",
        "            //>>> _params",
        "            var Code = inputs[(int)InputId.Code].Eval(context).Text;",
        "            var Image = inputs[(int)InputId.Image].Eval(context).Image; // Needs to be checked for null!",
        "            var Scale = inputs[(int)InputId.Scale].Eval(context).Value;",
        "            var Map = inputs[(int)InputId.Map].Eval(context).Dynamic;  // Needs to be checked for null!",
        "            var FiveTileSampleAmt = (int) inputs[(int)InputId.FiveTileSampleAmt].Eval(context).Value;",
        "            //<<< _params",
        "",
        "            return PrepareAndEvalOnChange(context, () => {",
        "            ",
        "            ",
        "                int dimensions = (int)Map[\"ChromaElements\"] + ((int)Map[\"LuminanceTiles\"].X * (int)Map[\"LuminanceTiles\"].Y);",
        "                int valuesPerTile = (int)Map[\"ValuesPerTile\"];",
        "                int mapEntryCount = (int)Math.Round(Math.Pow(valuesPerTile, dimensions));",
        "                    if (Scale <= 0) {",
        "                        Scale = (float)Map[\"Scale\"];",
        "                    }                    ",
        "                    if (Scale <= 0) {",
        "                        Scale = 1;",
        "                    }                    ",
        "",
        "",
        "                //Logger.Info(this,\"On change... hash code {0} vs. hash code {1}\", Map[\"HashCode\"], _lashHashCode);",
        "                //Logger.Info(this,\"CODE: {0}\", inputs[(int)InputId.Code].GetType());",
        "                var thisHashCode = Map[\"HashCode\"];",
        "                if (_lastHashCode != thisHashCode) {",
        "                    StringBuilder sb = new StringBuilder();",
        "                    sb.AppendLine(\"#define DIMENSIONS \" + dimensions.ToString());",
        "                    sb.AppendLine(\"#define VALUEELEMENTS \" + (dimensions + 2).ToString());",
        "                    int pixelFormat = Convert.ToInt32(Map[\"PixelFormat\"]);",
        "                    switch(pixelFormat) {",
        "                        case 0:",
        "                            sb.AppendLine(\"#define PIXELFORMAT_SQUARE\");",
        "                            break;",
        "                        case 1:",
        "                            sb.AppendLine(\"#define PIXELFORMAT_FIVETILE\");",
        "                            break;",
        "                        default:",
        "                            sb.AppendLine(\"#define PIXELFORMAT_UNKNOWN\");",
        "                            break;",
        "                    }",
        "                    int colorSpace = Convert.ToInt32(Map[\"ColorSpace\"]);",
        "                    switch(colorSpace) {",
        "                        case 0:",
        "                            sb.AppendLine(\"#define COLORSPACE_HSL\");",
        "                            break;",
        "                        case 1:",
        "                            sb.AppendLine(\"#define COLORSPACE_JPEG\");",
        "                            break;",
        "                        case 2:",
        "                            sb.AppendLine(\"#define COLORSPACE_LAB\");",
        "                            break;",
        "                        case 3:",
        "                            sb.AppendLine(\"#define COLORSPACE_NYUV\");",
        "                            break;",
        "                        default:",
        "                            sb.AppendLine(\"#define COLORSPACE_UNKNOWN\");",
        "                            break;",
        "                    }",
        "                    _defines = sb.ToString();",
        "                    //Logger.Info(this, \"Setting defines to = {0}\", _defines);",
        "    ",
        "                    Compile(0);",
        "                    //return;",
        "                }",
        "                ",
        "                _lastHashCode = thisHashCode;",
        "                //_lastScale = Scale;",
        "            ",
        "                ClearRenderTarget(context, new SharpDX.Color4(0, 0, 0, 0));",
        "        ",
        "                //>>> _setup",
        "                using (var ImageView = new ShaderResourceView(context.D3DDevice, Image))",
        "                {",
        "                    _effect.GetVariableByName(\"RenderTargetSize\").AsVector().Set(new Vector2(_usedViewport.Width, _usedViewport.Height));",
        "                    _effect.GetVariableByName(\"Image\").AsShaderResource().SetResource(ImageView);",
        "                    _effect.GetVariableByName(\"Scale\").AsScalar().Set(Scale);",
        "                    _effect.GetVariableByName(\"FiveTileSampleAmt\").AsScalar().Set(FiveTileSampleAmt);",
        "                    //<<< _setup",
        "                    ",
        "                    //Logger.Info(this, \"Hashcode = {0}\", Map[\"HashCode\"]);",
        "                    //Logger.Info(this, \"refimage w = {0}\", Map[\"FontImage\"].GetType());",
        "",
        "                    using (var RefImageView = new ShaderResourceView(context.D3DDevice, Map[\"RefImage\"]))",
        "                    using (var FontImageView = new ShaderResourceView(context.D3DDevice, Map[\"FontImage\"]))",
        "                    {",
        "                        //Logger.Debug(this,\"MapImageView is {0}\", MapImageView.GetType());",
        "                        _effect.GetVariableByName(\"RefImage\").AsShaderResource().SetResource(RefImageView);",
        "                        _effect.GetVariableByName(\"FontImage\").AsShaderResource().SetResource(FontImageView);",
        "                ",
        "                        _effect.GetVariableByName(\"CharSize\").AsVector().Set(Map[\"CharSize\"]);",
        "                        _effect.GetVariableByName(\"LuminanceTiles\").AsVector().Set(Map[\"LuminanceTiles\"]);",
        "                        _effect.GetVariableByName(\"ValuesPerTile\").AsScalar().Set(Map[\"ValuesPerTile\"]);",
        "                        _effect.GetVariableByName(\"ChromaElements\").AsScalar().Set(Map[\"ChromaElements\"]);",
        "                        _effect.GetVariableByName(\"PixelFormat\").AsScalar().Set(Map[\"PixelFormat\"]);",
        "                        _effect.GetVariableByName(\"ColorSpace\").AsScalar().Set(Map[\"ColorSpace\"]);",
        "                        ",
        "                        _effect.GetVariableByName(\"MapEntryCount\").AsScalar().Set(mapEntryCount);",
        "",
        "                        Render(context);",
        "                    }",
        "",
        "",
        "                //>>> _cleanup",
        "                }",
        "                //<<< _cleanup",
        "            });",
        "        }",
        "",
        "        string _lastHashCode = \"\";",
        "        string _defines = \"\";",
        "        ",
        "    }",
        "}",
        "",
        ""
      ],
      "AdditionalAssemblies": []
    }
  ],
  "Operators": [],
  "Connections": [
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "c62d900e-5bdc-446c-b109-2a3f113c965f",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "e0b5d238-3a1e-4324-95de-f92b14ffda58"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "5d24d5e3-f163-48ad-87e5-1526fa4504ec",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "c62d900e-5bdc-446c-b109-2a3f113c965f"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "0541526f-a45f-4055-ad52-72b9e2682d53",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "c62d900e-5bdc-446c-b109-2a3f113c965f"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "322bfe5f-5ec2-4842-a262-b34b729cd4e4",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "c62d900e-5bdc-446c-b109-2a3f113c965f"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "5e2d7ba7-1b22-4ea8-8f6f-102ceaadc304",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "c62d900e-5bdc-446c-b109-2a3f113c965f"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "d7478ed0-8900-4cc9-94aa-3b7e9925dee8",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "c62d900e-5bdc-446c-b109-2a3f113c965f"
    }
  ]
}